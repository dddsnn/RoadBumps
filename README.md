# Road surface quality analysis via Garmin bike computers

This repository contains software to record acceleration sensor data on a
Garmin Edge bike computer, and to analyze this data in order to deduce the
surface quality of roads along a ride.

## BumpVisualizer

`BumpVisualizer` is a ConnectIQ (fullscreen) app that displays the latest
acceleration sensor data and has the ability to record rides that include this
data. `BumpTools` is a library used by it. It has only been tested on the Edge
530.

### Usage

Once started, the app shows a simple graph with the latest raw acceleration
sensor data along the z axis scrolling from right to left, updating every
second. The sample rate is displayed at the top. The escape button exits the
app.

The activity start/pause button starts/stops an activity recording that
includes fit file fields for position, speed, and all raw acceleration values
(z axis). An active recording is indicated at the top ("rec", under the sample
rate). The app must stay running (i.e. remain fullscreen) during recording.

The device must be set to 1s recording rather than smart recording. This is
important, because the app has to fit all samples (25 per second) into limited
space available in .fit file data fields. Smart recording only writes data
fields at irregular intervals, and the app doesn't know which data has already
been written. It also can't check which recording mode is used, but using smart
recording will lead to unusable or at least highly discontinuous data.

### Data format

When recording, the app adds data fields for position (longitude/latitude) and
speed (in the end result, these seem to be duplicated, once set by the app,
once natively by the SDK).

It also adds several fields to hold all raw acceleration values along the z
axis. This is necessary because it only gets to write data once per second, but
25 32-bit sensor samples (in milli-g) arrive in that time.

First, each sample is fit into 16 bits: all values are capped to the range
[-32767, 32768]. The value -32768 is used to represent a null value.

A fit file field can hold an array of 8 16-bit signed ints, so 4 such fields
are created, with names `accel_z_0-8`, `accel_z_8-16`, `accel_z_16-24`, and
`accel_z_24-32`. When new sensor data arrives once per second, the arrays are
filled with it in order, i.e. the earliest sample is the first element in
`accel_z_0-8`, the latest sample is the first and also the last element in
`accel_z_24-32`. All other values in the last field are set to null (i.e.
-32768). The app then relies on the 1s recording mode to write the current
values of these fields before the next batch of data arrives from the sensor.

## Analyzer

`analyzer` contains a Python script that reads `.fit` files as generated by the
`BumpVisualizer`, analyzes the road surface quality along the ride, and plots
this data using matplotlib. Dependencies are listed in `src/requirements.txt`.

### Usage

Invoke the script like
```
python src/analyze.py [options] <fit_file> [<fit_file> ...]
```
which will open a matplotlib window with graphs of speed and accelerations on
the left side, and a map with the track color-coded by surface quality.

Specify `--save` to instead save the plot as an image, and `--plot-separately`
to show/save graphs and map separately.

### Displayed data

#### Graphs

The top graph shows acceleration values over time in milli-g. This is almost
raw data as recorded by the sensor, except that 1g is added to compensate
gravity and make sitting idle the baseline at zero.

In the middle is speed over time in km/h, raw data.

At the bottom is a rolling average of absolute acceleration over time, once
unmodified, and once attenuated by speed. To obtain the rolling average
absolute acceleration for a particular position, a few seconds of past
positions are collected (10 by default, configurable via
`--rolling-average-window-duration`) and the average of absolute acceleration
values calculated (like in the top graph, these are also adjusted to make
idling zero).

Attenuation by speed is done to account for the fact that vibrations become
naturally stronger the faster you go. The idea is to use a maximum attenuation
`att` when the speed is greater than a threshold `v_cap`. Attenuation here is
the fraction that is taken away from the input value, i.e. the higher it is,
the lower the result. For lower speeds, the attenuation is reduced linearly,
quadratically, or cubically. The formula for obtaining the attenuated version
`a_att` of the absolute average acceleration `a` is
```
a_att = (1 - (min(1, v / v_cap) ** exp) * att) * a
```
where `exp` is 1 for linear mode, 2 for quadratic and 3 for cubic.

E.g. for linear mode this means that for a speed of 0 the input `a` is taken
as-is, at a speed of `v_cap` `att * a` is subtracted, and in between the amount
that is subtracted scales linearly.

Attenuation can be specified via `--attenuation` in the format
`(linear|quadratic|cubic),<v_cap>,<att>` (default `linear,40,0.5`).

The threshold speed `v_cap` is also drawn as a horizontal line in the middle
graph.

#### Map

The right side shows a map plotting the track. The color of the track
represents the road quality and ranges from green (good) to red (bad). The
track is split into chunks of several seconds worth of positions (default 5,
configurable via `--track-time-slice`).

The color is calculated for each such chunk by averaging the attenuated average
absolute accelerations of positions in it (it's an average of an average). If
this value is 0, the chunk is drawn green, for values beyond a threshold
(default 300 mg, `--track-upper-limit`) the track is assumed to be maximally
bad and drawn red. Everything in between scales linearly between these colors.
The threshold at which the track is maximally bad is also plotted as a
horizontal line in the bottom graph.

The map also shows purple dots of varying sizes where the acceleration has
extreme spikes. The track is again split into chunks of several seconds
(default 1, `--spike-time-slice`). For each chunk, the maximum absolute
acceleration is considered (the actual maximum, not the rolling average). If
this is past a threshold (default 3000 mg, `--spike-lower-limit`) a dot is
drawn. The size scales linearly from smallest at that lower threshold to
largest at or beyond an upper threshold (default 4000 mg,
`--spike-upper-limit`). The thresholds for lower and upper limits are also
drawn as horizontal lines in the top graph.

Plotting of spikes can be disabled with `--no-spikes`.
